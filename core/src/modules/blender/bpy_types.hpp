/*
Copyright (C) 2024 Ian Sloat

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.

----------------------------------------------------------------------

Blender DNA and RNA wrapper classes for use in pybind functions.
Adds low level memory access to blender.
*/

#pragma once

#include <string>
#include "generated/blender_types.hpp"

void set_compatibility_mode(BlenderVersion version);

BlenderVersion get_compatability_mode();

class BlenderDataWrapper {
public:
	BlenderDataWrapper(void* data_ptr) : data_ptr(data_ptr) {};
	bool is_null() const { return data_ptr == nullptr; };
protected:
	void* data_ptr;
};

// Blender DNA enums

enum TrackFlags {
	TRACK_HAS_BUNDLE = (1 << 1),
	TRACK_DISABLE_RED = (1 << 2),
	TRACK_DISABLE_GREEN = (1 << 3),
	TRACK_DISABLE_BLUE = (1 << 4),
	TRACK_HIDDEN = (1 << 5),
	TRACK_LOCKED = (1 << 6),
	TRACK_CUSTOMCOLOR = (1 << 7),
	TRACK_USE_2D_STAB = (1 << 8),
	TRACK_PREVIEW_GRAYSCALE = (1 << 9),
	TRACK_DOPE_SEL = (1 << 10),
	TRACK_PREVIEW_ALPHA = (1 << 11),
	TRACK_USE_2D_STAB_ROT = (1 << 12),
};

// Blender DNA wrappers
class Library;
class AssetMetaData;
class IDProperty;
class IDOverrideLibrary;
class AnimData;
class bGPdata;
class bAction;
class bPose;
class bAnimVizSettings;
class bMotionPath;
class bFaceMap;
class DrawDataList;
class Ipo;
class MovieTracking;
class MovieTrackingSettings;
class MovieTrackingCamera;
class MovieTrackingReconstruction;
class MovieTrackingStabilization;
class MovieTrackingTrack;
class MovieTrackingPlaneTrack;
class MovieTrackingStats;
class MovieTrackingDopesheet;
class MovieTrackingObject;
class MovieTrackingMarker;
class MovieClipProxy;
class ColorManagedColorspaceSettings;
class MovieClip_Runtime;
class MovieClip;
class Material;
class ModifierData;
class GpencilModifierData;
class ShaderFxData;
class PartDeflect;
class SoftBody;
class Collection;
class FluidsimSettings;
class RigidBodyOb;
class RigidBodyCon;
class ImageUser;
class PreviewImage;
class ObjectLineArt;
class Object_Rumtime;
class Object;

template <typename T>
class ListBase : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	T first() const { return T(reinterpret_cast<ListBase2_93_0*>(data_ptr)->first); }
	T last() const { return T(reinterpret_cast<ListBase2_93_0*>(data_ptr)->last); }
};

template <typename T>
class ID : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	T next() const;
	T prev() const;
	ID newid() const;
	Library lib() const;
	AssetMetaData asset_data() const;
	std::string name() const;
	short flag() const;
	int tag() const;
	int us() const;
	int icon_id() const;
	unsigned int recalc() const;
	unsigned int session_uuid() const;
	IDProperty properties() const;
	IDOverrideLibrary override_library() const;
	ID orig_id() const;
};

class Library : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class AssetMetaData : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class IDProperty : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class IDOverrideLibrary : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

// Each DNA and RNA struct has autogenerated subtypes for specific blender versions. These macros must include each
// subtype in a if/else if statement. If not done properly, it can result in memory alignment issues and crashes.
// 
// All wrapper classes will have macros for their function definitions. Most of them can be found in bpy_types.cpp
#define ID_BASE_RETURN_BODY(A, B, C) \
	if (get_compatability_mode() < BlenderVersion::VER_3_0_0) \
		return A ( B reinterpret_cast<ID2_93_0*>(data_ptr)-> C); \
	else if (get_compatability_mode() < BlenderVersion::VER_3_2_0) \
		return A ( B reinterpret_cast<ID3_0_0*>(data_ptr)-> C); \
	else if (get_compatability_mode() < BlenderVersion::VER_3_4_0) \
		return A ( B reinterpret_cast<ID3_2_0*>(data_ptr)-> C); \
	else if (get_compatability_mode() < BlenderVersion::VER_4_1_0) \
		return A ( B reinterpret_cast<ID3_4_0*>(data_ptr)-> C); \
	else if (get_compatability_mode() < BlenderVersion::VER_4_2_0) \
		return A ( B reinterpret_cast<ID4_1_0*>(data_ptr)-> C); \
	return A ( B reinterpret_cast<ID4_2_0*>(data_ptr)-> C);

#define ID_RETURN_AS(T, M) ID_BASE_RETURN_BODY(T,, M)
#define ID_RETURN(M) ID_BASE_RETURN_BODY(,, M)

template <typename T>
T ID<T>::next() const { ID_RETURN_AS(T, next) }

template <typename T>
T ID<T>::prev() const { ID_RETURN_AS(T, prev) }

template <typename T>
ID<T> ID<T>::newid() const { ID_RETURN_AS(ID<T>, newid) }

template <typename T>
Library ID<T>::lib() const { ID_RETURN_AS(Library, lib) }

template <typename T>
AssetMetaData ID<T>::asset_data() const { ID_RETURN_AS(AssetMetaData, asset_data) }

template <typename T>
std::string ID<T>::name() const { ID_RETURN_AS(std::string, name) }

template <typename T>
short ID<T>::flag() const { ID_RETURN(flag) }

template <typename T>
int ID<T>::tag() const { ID_RETURN(tag) }

template <typename T>
int ID<T>::us() const { ID_RETURN(us) }

template <typename T>
int ID<T>::icon_id() const { ID_RETURN(icon_id) }

template <typename T>
unsigned int ID<T>::recalc() const { ID_RETURN(recalc) }

template <typename T>
unsigned int ID<T>::session_uuid() const { ID_RETURN(session_uuid) }

template <typename T>
IDProperty ID<T>::properties() const { ID_RETURN_AS(IDProperty, properties) }

template <typename T>
IDOverrideLibrary ID<T>::override_library() const { ID_RETURN_AS(IDOverrideLibrary, override_library) }

template <typename T>
ID<T> ID<T>::orig_id() const { ID_RETURN_AS(ID<T>, orig_id) }

class AnimData : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class bGPdata : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class bAction : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class bPose : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class bAnimVizSettings : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class bMotionPath : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class bFaceMap : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class DrawDataList : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class Ipo : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieTrackingSettings : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieTrackingCamera : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

typedef float(*Corners)[2];

class MovieTrackingMarker : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	float *pos() const;
	Corners pattern_corners() const;
	float *search_min() const;
	float *search_max() const;
	int &framenr() const;
	int &flag() const;
};

class MovieTrackingTrack : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	MovieTrackingTrack next() const;
	MovieTrackingTrack prev() const;
	const std::string name() const;
	float *offset() const;
	const int markersnr() const;
	MovieTrackingMarker markers(size_t idx) const;
	float *bundle_pos() const;
	float &error() const;
	int &flag() const;
	int &pat_flag() const;
	int &search_flag() const;
	float *color() const;
	short &frames_limit() const;
	short &margin() const;
	short &pattern_match() const;
	short &motion_model() const;
	int &algorithm_flag() const;
	float &minimum_correlation() const;
	bGPdata gpd() const;
	float &weight() const;
	float &weight_stab() const;
};

class MovieTrackingPlaneTrack : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieTrackingReconstruction : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieTrackingStabilization : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieTrackingObject : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	MovieTrackingObject next() const;
	MovieTrackingObject prev() const;
	const std::string name() const;
	int &flag() const;
	float &scale() const;
	ListBase<MovieTrackingTrack> tracks() const;
	ListBase<MovieTrackingPlaneTrack> plane_tracks() const;
	MovieTrackingReconstruction reconstruction() const;
	int &keyframe1() const;
	int &keyframe2() const;
};

class MovieTrackingStats : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieTrackingDopesheet : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieTracking : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	MovieTrackingSettings settings() const;
	MovieTrackingCamera camera() const;
	ListBase<MovieTrackingTrack> tracks() const;
	ListBase<MovieTrackingPlaneTrack> plane_tracks() const;
	MovieTrackingReconstruction reconstruction() const;
	MovieTrackingStabilization stabilization() const;
	MovieTrackingTrack active_track() const;
	MovieTrackingPlaneTrack active_plane_track() const;
	ListBase<MovieTrackingObject> objects() const;
	const int objectnr() const;
	const int tot_objects() const;
	MovieTrackingStats stats() const;
	MovieTrackingDopesheet dopesheet();
};

class MovieClipProxy : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class ColorManagedColorspaceSettings : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieClip_Runtime : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MovieClip : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	ID<MovieClip> id() const;
	AnimData anim_data() const;
	const std::string filepath() const;
	int source() const;
	int *last_size() const;
	float aspect_x() const;
	float aspect_y() const;
	bGPdata grease_pencil_data() const;
	MovieTracking tracking() const;
	int flag() const;
	int length() const;
	int &start_frame() const;
	int &frame_offset() const;
	ColorManagedColorspaceSettings colorspace_settings() const;
	MovieClip_Runtime runtime() const;
};

class Material : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class ModifierData : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class GpencilModifierData : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class ShaderFxData : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class PartDeflect : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class SoftBody : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class Collection : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class FluidsimSettings : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class RigidBodyOb : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class RigidBodyCon : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class ImageUser : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class PreviewImage : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class ObjectLineArt : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class Object_Rumtime : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
};

class MaterialSlot {
public:
	MaterialSlot(void** materials, char* matbits, size_t mat_idx) : materials(materials), matbits(matbits), mat_idx(mat_idx) {}
	Material material() const;
	bool is_linked() const;
private:
	void** materials;
	char* matbits;
	size_t mat_idx;
};

class MaterialSlotArray {
public:
	MaterialSlotArray(void** materials, char* matbits, size_t totcol) : materials(materials), matbits(matbits), totcol(totcol) {}
	size_t size() const;
	MaterialSlot operator[](const size_t idx) const;
private:
	void** materials;
	char* matbits;
	size_t totcol;
};

typedef float(*Mat)[4];

class Object : public BlenderDataWrapper {
public:
	using BlenderDataWrapper::BlenderDataWrapper;
	ID<Object> id() const;
	AnimData adt() const;
	DrawDataList drawdata() const;
	short type() const;
	short partype() const;
	int par1() const;
	int par2() const;
	int par3() const;
	std::string parsubstr() const;
	Object parent() const;
	Object track() const;
	Object proxy() const;
	Object proxy_group() const;
	Object proxy_from() const;
	Ipo ipo() const;
	bAction action() const;
	bAction poselib() const;
	bPose pose() const;
	bGPdata gpd() const;
	bAnimVizSettings avs() const;
	bMotionPath mpath() const;
	ListBase<ModifierData> modifiers() const;
	ListBase<GpencilModifierData> greasepencil_modifiers() const;
	ListBase<bFaceMap> fmaps() const;
	ListBase<ShaderFxData> shader_fx() const;
	int& mode() const;
	int& restore_mode() const;
	MaterialSlotArray materials() const;
	MaterialSlot active_mat() const;
	float* loc() const;
	float* dloc() const;
	float* scale() const;
	float* dscale() const;
	float* rot() const;
	float* drot() const;
	float* quat() const;
	float* dquat() const;
	float* rotAxis() const;
	float* drotAxis() const;
	float& rotAngle() const;
	float& drotAngle() const;
	Mat obmat() const;
	Mat parentinv() const;
	Mat constinv() const;
	Mat imat() const;
	short& flag() const;
	short& transflag() const;
	short& protectflag() const;
	short& trackflag() const;
	short& upflag() const;
	short& nlaflag() const;
	char& duplicator_visibility_flag() const;
	short& base_flag() const;
	unsigned short base_local_view_bits() const;
	unsigned short& col_group() const;
	unsigned short& col_mask() const;
	short& rotmode() const;
	char& boundtype() const;
	char& collision_boundtype() const;
	short& dtx() const;
	char& dt() const;
	char& empty_drawtype() const;
	float& empty_drawsize() const;
	float& instance_faces_scale() const;
	short& index() const;
	unsigned short& actdef() const;
	unsigned short& actfmap() const;
	float* color() const;
	short& softflag() const;
	char& shapeflag() const;
	short& shapenr() const;
	// Add ListBase constraints and particlesystem once exact type is identified
	PartDeflect pd() const;
	SoftBody soft() const;
	Collection instance_collection() const;
	// Add ListBase pc_ids once exact type is identified
	RigidBodyOb rigidbody_object() const;
	RigidBodyCon rigidbody_constraint() const;
	float* ima_ofs() const;
	ImageUser iuser() const;
	char& empty_image_visibility_flag() const;
	char& empty_image_depth() const;
	char& empty_image_flag() const;
	PreviewImage preview() const;
	ObjectLineArt lineart() const;
	Object_Rumtime runtime() const;
private:
	void** mat() const;
	char* matbits() const;
	int totcol() const;
	int actcol() const;
};
